package com.thirdplace.usertabledriver;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.thirdplace.thirdplacedatabaseservice.ColumnSetter;
import com.thirdplace.thirdplacedatabaseservice.DatabaseServiceResults;
import com.thirdplace.thirdplacedatabaseservice.TableColumnType;
import com.thirdplace.thirdplacedatabaseservice.ThirdPlaceDatabaseService;
import com.thirdplace.thirdplacedatabaseservice.WhereFilter;
import com.thirdplace.utils.RecordUtils;
import com.thirdplace.thirdplacedatabaseservice.DatabaseServiceResults.DeleteResult;
import com.thirdplace.thirdplacedatabaseservice.DatabaseServiceResults.InsertResult;
import com.thirdplace.thirdplacedatabaseservice.DatabaseServiceResults.QueryResult;
import com.thirdplace.thirdplacedatabaseservice.DatabaseServiceResults.UpdateResult;

import jakarta.annotation.Nullable;

/**
 * Class to drive the user table creation and manipulation
 */
public class UserTableDriver {

    private static final Logger LOGGER = LoggerFactory.getLogger(UserTableDriver.class);

    public static final String TABLE_NAME = "users";

    public static final String ID_COLUMN = "id";
    public static final String USERNAME_COLUMN = "username";
    public static final String PASSWORD_COLUMN = "password";
    public static final String EMAIL_COLUMN = "email";
    public static final String FIRST_NAME_COLUMN = "firstName";
    public static final String LAST_NAME_COLUMN = "lastName";
    public static final String CREATED_AT_COLUMN = "created_at";
    public static final String UPDATED_AT_COLUMN = "updated_at";

    private static final String WILDCARD = "*";
    private static final String TEXT_CAST = "::text";

    private static final List<TableColumnType> COLUMN_TYPES = List.of(
            // Serial ID - auto increments integer
            new TableColumnType(ID_COLUMN, "INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY UNIQUE"),
            new TableColumnType(USERNAME_COLUMN, "TEXT NOT NULL"),
            new TableColumnType(PASSWORD_COLUMN, "TEXT NOT NULL"), new TableColumnType(EMAIL_COLUMN, "TEXT NOT NULL"),
            new TableColumnType(FIRST_NAME_COLUMN, "TEXT"), new TableColumnType(LAST_NAME_COLUMN, "TEXT"),
            new TableColumnType(CREATED_AT_COLUMN, "TEXT DEFAULT CURRENT_TIMESTAMP"),
            new TableColumnType(UPDATED_AT_COLUMN, "TEXT DEFAULT CURRENT_TIMESTAMP"));

    // Columns used to update a user
    private static final List<String> UPDATE_COLUMNS = List.of(USERNAME_COLUMN, PASSWORD_COLUMN, EMAIL_COLUMN,
            FIRST_NAME_COLUMN, LAST_NAME_COLUMN);

    final ThirdPlaceDatabaseService dbService;

    public UserTableDriver(final ThirdPlaceDatabaseService dbService) {
        LOGGER.debug("Creating UserTableDriver");
        this.dbService = dbService;

    }

    /**
     * Initializes the user table, or does nothing if the table already exists
     */
    public void init() {

        LOGGER.debug("Initializing UserTableDriver");

        // Create the users table
        dbService.createTable(TABLE_NAME, COLUMN_TYPES);
    }

    /**
     * Insert a user record into the users table
     * 
     * @param userRecord The user record to insert
     * @return The results of the insert operation
     */
    public UserRecordResult insertUserRecord(final UserRecordInsert userRecord) {
        LOGGER.debug("Inserting user record: " + userRecord);

        // Set the input values to the update columns, defaulting empty string for null
        // values
        final Map<String, String> inputValues = UPDATE_COLUMNS.stream().collect(Collectors.toMap(c -> c, c -> {
            final Object recordValue = RecordUtils.getRecordValue(userRecord, c);
            return Objects.isNull(recordValue) ? StringUtils.EMPTY : recordValue.toString();
        }));
        final List<ColumnSetter> columnSetters = UPDATE_COLUMNS.stream()
                .filter(nullSafeColumn -> !StringUtils.isEmpty(inputValues.get(nullSafeColumn)))
                .map(column -> new ColumnSetter(column, inputValues.get(column))).toList();

        // Insert using the update columns, as the other ones are automatically
        // generated by the db
        final DatabaseServiceResults<InsertResult> insertResult = dbService.insertRecord(TABLE_NAME, columnSetters);

        // If the db threw an exception, throw it back up
        if (!insertResult.successful()) {
            throw new UserTableDriverException(UserTableDriverException.ErrorCode.ERROR_INSERTING_USER,
                    "Error trying to insert user record " + userRecord, insertResult.exception());
        }

        final Map<String, Object> result = insertResult.result().inserted();

        // Columns come back lowercased in the map, so lowercase column names
        return new UserRecordResult(result.get(ID_COLUMN.toLowerCase()).toString(), 
                result.getOrDefault(USERNAME_COLUMN, StringUtils.EMPTY).toString(),
                result.getOrDefault(EMAIL_COLUMN.toLowerCase(), StringUtils.EMPTY).toString(), 
                result.get(FIRST_NAME_COLUMN.toLowerCase()).toString(),
                result.get(LAST_NAME_COLUMN.toLowerCase()).toString(), 
                result.get(CREATED_AT_COLUMN.toLowerCase()).toString(),
                result.get(UPDATED_AT_COLUMN.toLowerCase()).toString());
    }

    /**
     * Update a user record in the users table. The id of the input record is what
     * will be used to filter the record to update
     * 
     * @param userRecord The user mutation record
     * @return The resulting record of the update operation.
     */
    @Nullable
    public UserRecordResult updateUserRecord(final UserRecordMutate userRecord) {
        LOGGER.debug("Updating user record: " + userRecord);

        if (userRecord.id() == null) {
            throw new UserTableDriverException(UserTableDriverException.ErrorCode.ERROR_UPDATING_NULL_ID,
                    "User record id cannot be null for update operation " + userRecord);
        }

        // Set the input values to the update columns, making sure to skip null columns
        // as null columns implies we don't want to change the value
        final Map<String, String> inputValues = UPDATE_COLUMNS.stream()
                .filter(c -> !Objects.isNull(RecordUtils.getRecordValue(userRecord, c)))
                .collect(Collectors.toMap(c -> c, c -> RecordUtils.getRecordValue(userRecord, c).toString()));
        final List<ColumnSetter> columnSetters = UPDATE_COLUMNS.stream()
                .filter(nullSafeColumn -> !StringUtils.isEmpty(inputValues.get(nullSafeColumn)))
                .map(column -> new ColumnSetter(column, inputValues.get(column))).toList();

        // Filter where id (cast text) equals the input record id
        final WhereFilter userFilter = new WhereFilter(ID_COLUMN + TEXT_CAST, WhereFilter.Operator.EQUAL,
                Integer.toString(userRecord.id()));

        final DatabaseServiceResults<UpdateResult> dbUpdateResult = dbService.updateRecord(TABLE_NAME, columnSetters,
                List.of(userFilter), true);

        if (!dbUpdateResult.successful()) {
            throw new UserTableDriverException(UserTableDriverException.ErrorCode.ERROR_UPDATING_USER,
                    "Error trying to update user record " + userRecord, dbUpdateResult.exception());
        }

        final List<Map<String, Object>> updatedRecords = dbUpdateResult.result().updated();
        if (updatedRecords.isEmpty()) {
            throw new UserTableDriverException(UserTableDriverException.ErrorCode.ERROR_UPDATING_USER_NOT_FOUND,
                    "No user record found to update with id " + userRecord.id());
        }

        final Map<String, Object> updatedUserRecord = updatedRecords.getFirst();
        return new UserRecordResult(updatedUserRecord.get(ID_COLUMN).toString(),
                updatedUserRecord.get(USERNAME_COLUMN).toString(), updatedUserRecord.get(EMAIL_COLUMN).toString(),
                updatedUserRecord.get(FIRST_NAME_COLUMN).toString(), updatedUserRecord.get(LAST_NAME_COLUMN).toString(),
                updatedUserRecord.get(CREATED_AT_COLUMN).toString(),
                updatedUserRecord.get(UPDATED_AT_COLUMN).toString());

    }

    /**
     * Delete a user record from the users table using the id from the input record.
     * Other properties are ignored.
     * 
     * @param userRecord The user record to delete
     * @return The results of the delete operation
     */
    public DatabaseServiceResults<DeleteResult> deleteUserRecord(final UserRecordMutate userRecord) {
        LOGGER.debug("Deleting user record: " + userRecord);

        if (userRecord.id() == null) {
            throw new UserTableDriverException(UserTableDriverException.ErrorCode.ERROR_DELETING_NULL_ID,
                    "User record id cannot be null for delete operation " + userRecord);
        }

        // Filter where id (cast text) equals the input record id
        final WhereFilter userFilter = new WhereFilter(ID_COLUMN + TEXT_CAST, WhereFilter.Operator.EQUAL,
                Integer.toString(userRecord.id()));

        return dbService.deleteRecord(TABLE_NAME, List.of(userFilter));
    }

    /**
     * Get user record from the table based on criteria
     * 
     * @param recordFilters The filters to apply to the select operation
     * @return The results of the select operation
     */
    public DatabaseServiceResults<QueryResult> getUserRecord(final List<WhereFilter> recordFilters) {
        return dbService.queryRecord(TABLE_NAME, List.of(WILDCARD), recordFilters);
    }

}
